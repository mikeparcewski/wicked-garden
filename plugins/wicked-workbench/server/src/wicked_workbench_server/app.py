"""
Wicked Workbench Server

FastAPI application serving the A2UI-powered dashboard.
Renders A2UI documents generated by Claude Code and fetches data from MCP servers.
"""

import json
import os
from contextlib import asynccontextmanager
from pathlib import Path
from typing import Any

from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from starlette.middleware.sessions import SessionMiddleware

from .auth import init_db, router as auth_router
from .catalog_loader import Catalog, CatalogLoader
from .prompt_generator import PromptGenerator
from .bridges.mcp_bridge import MCPBridge
from .acp import router as acp_router, init_acp, cleanup_acp


# Global state
catalog_loader: CatalogLoader | None = None
prompt_generator: PromptGenerator | None = None
mcp_bridge: MCPBridge | None = None
current_document: list[dict[str, Any]] | None = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan handler."""
    global catalog_loader, prompt_generator, mcp_bridge

    # Initialize database
    print("[Workbench] Initializing database...")
    init_db()

    # Initialize components
    plugins_dir = os.environ.get("WICKED_PLUGINS_DIR")
    catalog_loader = CatalogLoader(plugins_dir)
    prompt_generator = PromptGenerator()
    mcp_bridge = MCPBridge()

    # Discover catalogs
    catalogs = catalog_loader.discover()
    for catalog in catalogs:
        prompt_generator.add_catalog(catalog)

    # Load built-in catalogs if no plugins found
    if not catalogs:
        print("[Workbench] No plugin catalogs found, loading built-ins")
        load_builtin_catalogs()

    print(f"[Workbench] Ready with {len(catalog_loader.catalogs)} catalogs")

    # Initialize ACP bridge (optional - gracefully degrades if claude-code-acp not installed)
    try:
        await init_acp()
        print("[Workbench] ACP Bridge initialized")
    except Exception as e:
        print(f"[Workbench] ACP Bridge not available: {e}")
        print("[Workbench] Install with: npm install -g @zed-industries/claude-code-acp")

    yield

    # Cleanup
    await cleanup_acp()
    if mcp_bridge:
        await mcp_bridge.close()


def load_builtin_catalogs():
    """Load built-in catalogs for demo/testing."""
    global catalog_loader, prompt_generator

    # Kanban catalog
    kanban_catalog = {
        "catalogId": "kanban",
        "version": "1.0.0",
        "description": "Kanban board components for task management",
        "components": {
            "KanbanBoard": {
                "description": "A kanban board displaying tasks organized into columns by status",
                "props": {
                    "columns": {"type": "array", "description": "Column names", "default": ["To Do", "In Progress", "Done"]}
                },
                "slots": {"children": {"role": "content", "description": "Task cards to display", "accepts": ["TaskCard"]}}
            },
            "TaskCard": {
                "description": "A card representing a single task",
                "props": {
                    "title": {"type": "string", "required": True, "description": "Task title"},
                    "description": {"type": "string", "description": "Task details"},
                    "status": {"type": "string", "enum": ["To Do", "In Progress", "Done", "blocked"], "description": "Current status"},
                    "priority": {"type": "string", "enum": ["critical", "high", "medium", "low"], "description": "Priority level"},
                    "tags": {"type": "array", "description": "Category labels"}
                }
            },
            "TaskList": {
                "description": "A vertical list of tasks",
                "props": {"title": {"type": "string", "description": "List header"}},
                "slots": {"children": {"role": "content", "description": "Task cards to display", "accepts": ["TaskCard"]}}
            },
            "TaskCount": {
                "description": "A numeric badge showing task count",
                "props": {
                    "count": {"type": ["number", "object"], "required": True, "description": "Count value or data binding"},
                    "label": {"type": "string", "description": "Text after number"},
                    "variant": {"type": "string", "enum": ["default", "warning"], "description": "Visual style"}
                }
            }
        },
        "intents": {
            "show-all-tasks": {"description": "Display all tasks in kanban format", "suggestedComponents": ["KanbanBoard", "TaskCard"]},
            "show-blocked-tasks": {"description": "Show blocked tasks", "suggestedComponents": ["TaskList", "TaskCard", "TaskCount"]}
        }
    }

    # Memory catalog
    memory_catalog = {
        "catalogId": "memory",
        "version": "1.0.0",
        "description": "Memory and context components",
        "components": {
            "MemoryPanel": {
                "description": "A panel displaying memory items",
                "props": {
                    "title": {"type": "string", "description": "Panel header"},
                    "count": {"type": "number", "description": "Item count badge"}
                },
                "slots": {"children": {"role": "content", "description": "Memory items to display", "accepts": ["MemoryItem"]}}
            },
            "MemoryItem": {
                "description": "A single memory entry",
                "props": {
                    "type": {"type": "string", "enum": ["decision", "procedural", "episodic", "preference"], "description": "Memory type"},
                    "content": {"type": "string", "required": True, "description": "Memory content"},
                    "timestamp": {"type": "string", "description": "ISO timestamp"},
                    "tags": {"type": "array", "description": "Category tags"}
                }
            },
            "ContextSummary": {
                "description": "A highlighted summary box",
                "props": {
                    "title": {"type": "string", "description": "Summary heading"},
                    "summary": {"type": "string", "required": True, "description": "Summary text"}
                }
            }
        },
        "intents": {
            "show-context": {"description": "Show related context", "suggestedComponents": ["MemoryPanel", "MemoryItem"]},
            "show-decisions": {"description": "Show decisions", "suggestedComponents": ["MemoryPanel", "MemoryItem"]}
        }
    }

    catalog_loader.load_from_json(kanban_catalog)
    catalog_loader.load_from_json(memory_catalog)

    for catalog in catalog_loader.get_all_catalogs():
        prompt_generator.add_catalog(catalog)


app = FastAPI(
    title="Wicked Workbench",
    description="A2UI renderer for wicked-garden plugins. Claude Code generates the A2UI, workbench renders it.",
    version="0.1.0",
    lifespan=lifespan
)

# Session middleware for OAuth state management
app.add_middleware(
    SessionMiddleware,
    secret_key=os.environ.get("SESSION_SECRET_KEY", "change-me-in-production-please")
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth_router)
app.include_router(acp_router)


# === API Models ===

class RenderRequest(BaseModel):
    """Request to render an A2UI document."""
    document: list[dict[str, Any]]
    fetch_data: bool = True


class RenderResponse(BaseModel):
    """Response with rendered dashboard."""
    validation: dict[str, Any]
    data: dict[str, Any] | None = None


class DataRequest(BaseModel):
    """Request to fetch data for a document."""
    data_needs: list[str]


# === API Endpoints ===

@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "healthy", "service": "wicked-workbench"}


@app.get("/api/plugins")
async def discover_plugins():
    """Discover all installed wicked-garden plugins with their metadata and UI manifests.

    Scans ~/.claude/plugins/ for all plugin directories, loading:
    - plugin.json: Plugin metadata (name, version, description, commands, etc.)
    - catalog.json: A2UI component catalog (if present)
    - ui-manifest.json: UI layout and views manifest (if present)

    Returns a list of DiscoveredPlugin objects sorted by manifest navigation order.
    """
    plugins_base = Path.home() / ".claude" / "plugins"
    discovered = []

    if not plugins_base.exists():
        return []

    # Also check the cache directory structure
    cache_base = plugins_base / "cache"
    search_paths = []

    # Direct plugin installations
    for plugin_dir in sorted(plugins_base.iterdir()):
        if plugin_dir.is_dir() and plugin_dir.name.startswith("wicked-"):
            search_paths.append(plugin_dir)

    # Cached plugin installations (cache/wicked-garden/plugin-name/version/)
    wg_cache = cache_base / "wicked-garden" if cache_base.exists() else None
    if wg_cache and wg_cache.exists():
        for plugin_dir in sorted(wg_cache.iterdir()):
            if plugin_dir.is_dir() and plugin_dir.name.startswith("wicked-"):
                # Use latest version
                versions = sorted(plugin_dir.iterdir(), reverse=True)
                if versions:
                    search_paths.append(versions[0])

    for plugin_path in search_paths:
        plugin_json = plugin_path / ".claude-plugin" / "plugin.json"
        if not plugin_json.exists():
            continue

        try:
            with open(plugin_json) as f:
                info = json.load(f)

            # Load UI manifest if present
            manifest = None
            manifest_path = plugin_path / ".claude-plugin" / "ui-manifest.json"
            if manifest_path.exists():
                with open(manifest_path) as f:
                    manifest = json.load(f)

            # Load catalog if present
            catalog = None
            catalog_path = plugin_path / ".claude-plugin" / "catalog.json"
            if catalog_path.exists():
                with open(catalog_path) as f:
                    catalog = json.load(f)

            plugin_name = info.get("name", plugin_path.name)

            # Extract command/agent/skill names from plugin.json
            commands = [c.get("name", "") for c in info.get("commands", []) if isinstance(c, dict)]
            agents = [a.get("name", "") for a in info.get("agents", []) if isinstance(a, dict)]
            skills = [s.get("name", "") for s in info.get("skills", []) if isinstance(s, dict)]

            discovered.append({
                "name": plugin_name,
                "info": {
                    "name": plugin_name,
                    "version": info.get("version", "0.0.0"),
                    "description": info.get("description", ""),
                    "commands": commands,
                    "agents": agents,
                    "skills": skills,
                },
                "manifest": manifest,
                "catalog": catalog,
            })

        except (json.JSONDecodeError, OSError) as e:
            print(f"[Workbench] Error loading plugin {plugin_path.name}: {e}")
            continue

    # Sort by manifest navigation order (plugins with manifests first)
    discovered.sort(key=lambda p: (
        0 if p["manifest"] else 1,
        p["manifest"]["navigation"]["order"] if p.get("manifest") else 999,
        p["name"],
    ))

    return discovered


@app.get("/api/catalogs")
async def list_catalogs():
    """List available catalogs for Claude Code to use in generation."""
    catalogs = catalog_loader.get_all_catalogs()
    return {
        "catalogs": [
            {
                "id": c.id,
                "version": c.version,
                "description": c.description,
                "components": list(c.components.keys()),
                "intents": list(c.intents.keys())
            }
            for c in catalogs
        ]
    }


@app.get("/api/catalogs/{catalog_id}")
async def get_catalog(catalog_id: str):
    """Get a specific catalog for Claude Code to use in generation."""
    if catalog_id == "workbench":
        catalog = catalog_loader.get_merged_catalog()
    else:
        catalog = catalog_loader.get_catalog(catalog_id)

    if not catalog:
        raise HTTPException(status_code=404, detail=f"Catalog not found: {catalog_id}")

    return catalog.model_dump()


@app.get("/api/prompt")
async def get_prompt():
    """Get the system prompt for Claude Code to use when generating A2UI."""
    prompt = prompt_generator.generate_system_prompt()
    return {
        "prompt": prompt,
        "length": len(prompt),
        "estimated_tokens": prompt_generator.estimate_tokens(prompt),
        "catalog_ids": prompt_generator.get_catalog_ids()
    }


@app.post("/api/render", response_model=RenderResponse)
async def render_dashboard(request: RenderRequest):
    """
    Render an A2UI document generated by Claude Code.

    Claude Code generates the A2UI JSON, sends it here for rendering.
    Workbench validates, fetches live data, and displays.
    """
    global current_document

    # Store the document for the UI to fetch
    current_document = request.document

    # Validate document structure
    validation = validate_a2ui_document(request.document)

    # Analyze data needs and fetch if requested
    data = None
    if request.fetch_data and validation["valid"]:
        data_needs = analyze_data_needs(request.document)
        data = await mcp_bridge.fetch_for_document(data_needs) if data_needs else None

    return RenderResponse(validation=validation, data=data)


@app.get("/api/current")
async def get_current_document():
    """Get the current A2UI document being displayed."""
    if not current_document:
        return {"document": None, "message": "No dashboard loaded. Use Claude Code to generate one."}
    return {"document": current_document}


@app.post("/api/data")
async def fetch_data(request: DataRequest):
    """Fetch data from MCP servers."""
    data = await mcp_bridge.fetch_for_document(request.data_needs)
    return {"data": data}


@app.get("/api/servers")
async def check_servers():
    """Check MCP server availability."""
    status = await mcp_bridge.check_servers()
    return {"servers": status}


def validate_a2ui_document(document: list[dict[str, Any]]) -> dict[str, Any]:
    """Validate an A2UI document structure."""
    errors = []

    if not isinstance(document, list):
        errors.append("Document must be an array of messages")
        return {"valid": False, "errors": errors}

    has_surface = False
    has_root = False
    component_ids = set()
    referenced_ids = set()

    for msg in document:
        if "createSurface" in msg:
            has_surface = True
            surface = msg["createSurface"]
            if not surface.get("surfaceId"):
                errors.append("createSurface missing surfaceId")
            if not surface.get("catalogId"):
                errors.append("createSurface missing catalogId")

        if "updateComponents" in msg:
            update = msg["updateComponents"]
            if not update.get("surfaceId"):
                errors.append("updateComponents missing surfaceId")

            for comp in update.get("components", []):
                comp_id = comp.get("id")
                if not comp_id:
                    errors.append("Component missing id")
                else:
                    component_ids.add(comp_id)
                    if comp_id == "root":
                        has_root = True

                if not comp.get("component"):
                    errors.append(f"Component {comp_id} missing component type")

                # Track child references
                for child_id in comp.get("children", []):
                    if isinstance(child_id, str):
                        referenced_ids.add(child_id)

    if not has_surface:
        errors.append("Document must have createSurface message")
    if not has_root:
        errors.append("Components must include a 'root' component")

    # Check for dangling references
    for ref_id in referenced_ids:
        if ref_id not in component_ids:
            errors.append(f"Referenced component '{ref_id}' not defined")

    return {
        "valid": len(errors) == 0,
        "errors": errors,
        "stats": {
            "components": len(component_ids),
            "references": len(referenced_ids)
        }
    }


def analyze_data_needs(document: list[dict[str, Any]]) -> list[str]:
    """Analyze an A2UI document to determine data needs."""
    needs = set()

    for msg in document:
        if "updateComponents" in msg:
            for comp in msg["updateComponents"].get("components", []):
                comp_type = comp.get("component", "")
                if comp_type in ("TaskCard", "KanbanBoard", "TaskList"):
                    needs.add("tasks")
                if comp_type in ("MemoryItem", "MemoryPanel"):
                    needs.add("memories")
                if comp_type == "TaskCount":
                    needs.add("stats")

    return list(needs)


# === Static Files & UI ===

# Serve static files if they exist
static_dir = Path(__file__).parent / "static"
if static_dir.exists():
    app.mount("/static", StaticFiles(directory=static_dir), name="static")


@app.get("/", response_class=HTMLResponse)
async def index():
    """Serve the dashboard UI."""
    return """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wicked Workbench</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        h1 { color: #7c3aed; margin-bottom: 8px; }
        .subtitle { color: #888; margin-bottom: 24px; }
        .info {
            background: #16213e;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }
        .info h3 { color: #7c3aed; margin-bottom: 8px; }
        .info code {
            background: #0f0f23;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .info pre {
            background: #0f0f23;
            padding: 12px;
            border-radius: 4px;
            margin-top: 8px;
            overflow-x: auto;
            font-size: 0.85rem;
        }
        #surface {
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            min-height: 400px;
            background: #16213e;
        }
        .status { font-size: 0.875rem; color: #888; margin-top: 16px; }
        .waiting { color: #7c3aed; }
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #7c3aed;
            color: white;
            cursor: pointer;
            margin-top: 12px;
        }
        button:hover { background: #6d28d9; }
    </style>
</head>
<body>
    <h1>üîß Wicked Workbench</h1>
    <p class="subtitle">A2UI dashboard renderer for wicked-garden plugins</p>

    <div class="info">
        <h3>How It Works</h3>
        <p>Claude Code generates A2UI dashboards. This server renders them.</p>
        <pre>User: "Show blocked tasks"
     ‚Üì
Claude Code: generates A2UI JSON
     ‚Üì
Workbench: renders + fetches live data</pre>
        <p style="margin-top: 12px;">In Claude Code, ask for a dashboard and it will send the A2UI here.</p>
    </div>

    <div id="surface">
        <p class="waiting">Waiting for Claude Code to send a dashboard...</p>
        <button onclick="checkForDashboard()">Check for Dashboard</button>
    </div>

    <div class="status" id="status"></div>

    <script>
        async function checkForDashboard() {
            const surface = document.getElementById('surface');
            const status = document.getElementById('status');

            try {
                const response = await fetch('/api/current');
                const result = await response.json();

                if (result.document) {
                    status.textContent = '‚úÖ Dashboard loaded';
                    renderA2UI(surface, result.document);
                } else {
                    status.textContent = 'No dashboard yet. Ask Claude Code to generate one.';
                }
            } catch (e) {
                status.textContent = '‚ùå ' + e.message;
            }
        }

        // Simple A2UI renderer
        function renderA2UI(container, document) {
            container.innerHTML = '<pre style="color: #888; font-size: 0.75rem; overflow: auto;">' +
                JSON.stringify(document, null, 2) + '</pre>';
        }

        // Auto-check on load
        checkForDashboard();

        // Poll for updates
        setInterval(checkForDashboard, 5000);
    </script>
</body>
</html>"""
